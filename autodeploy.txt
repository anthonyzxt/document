#自动化部署
- 环境的规划
	- 开发环境  
	    >开发者自己的环境，这个需要运维设置的开发环境，大家共用
	- 测试环境  
	    >功能测试环境和性能测试环境
	- 预生产环境  
		>生产环境集群中的某一个节点担任。  
		>产生的原因：数据库不一致;使用生产环境的联调接口，如：支付接口
	- 生产环境  
		>直接对用户提供服务的环境
##构建自动化部署的规划
1. 规划
2. 实现
3. 总结和扩展
###1. 规划
1. 集群有10个节点
	1. 实现一键部署10个节点
	2. 一键回滚到任意版本
	3. 一键回滚到上个版本
2. 部署
	1. git svn
	2. 代码的获取
		- svn+git直接拉取某个分支
		- svn:指定版本号
		- git:指定tag
	3. 差异解决
		1. 各个节点有差异，配置文件不一样，crontab.xml 预生产节点
		2. 代码仓库和实际的差异。配置文件是否在代码仓库中。配置文件只在部署上有，单独的项目
	4. 如何更新。Java tomcat需要更新
	5. 测试
	6. 串行和并行
		1. 分组 `salt -b`
	7. 如何执行
		1. shell ./执行
		2. web界面
###2. 流程设计
1. 获取代码（直接拉取）
2. 编译（可选）
3. 配置文件放进去
4. 打包
5. scp到目标服务器
6. 将目标服务器移除集群
7. 解压
8. 放置到webroot
9. scp差异文件
10. 重启（可选）
11. 测试
12. 加入集群
###3. 实现的shell函数
- 关于uuid
	blkid 文件
- 关于自动部署问题
	- 是否多人执行：加入锁文件
	- 记录执行日志
- 代码部分(基于shell)
	<pre># cat deploy.sh   
	#!/bin/bash
	#Node list
	Node_list="172.16.1.160 172.16.1.171"
	#Date/Time variable
	CDate=$(date "+%Y-%m-%d")
	CTime=$(date "+%H-%M-%S")
	
	Log_Date='date "+%Y-%m-%d"'
	Log_Time='date "+%H-%M-%S"'
	
	#shell env
	Shell_name="deploy.sh"
	Shell_dir="/home/www"
	Shell_log="${Shell_dir}/${Shell_name}.log"
	
	#code env
	Pro_name="web-demo"
	Code_dir="/deploy/code/web-demo"
	Config_dir="/deploy/config"
	Tmp_dir="/deploy/tmp"
	Tar_dir="/deploy/tar"
	Lock_file="/var/run/deploy.lock"
	
	usage(){
	  echo "Usage: $0 {deploy | rollback}"
	}
	
	writelog(){
	  LOGINFO=$1
	  echo "${CDate}${CTime}: ${Shell_name}: ${LOGINFO} ">>${Shell_log}
	}
	shell_lock(){
	  touch ${Lock_file}
	}
	
	shell_unlock(){
	  rm -f ${Lock_file}
	}
	code_get(){
	  writelog "code_get"
	  cd ${Code_dir} && git pull
	  cp -r ${Code_dir} ${Tmp_dir}/
	  Api_ver="123"
	}
	code_build(){
	  echo code_build
	}
	
	code_config(){
	  echo code_config
	  /bin/cp -r ${Config_dir}/* ${Tmp_dir}/${Pro_name}
	  Pkg_name=${Pro_name}_${Api_ver}_${CDate}_${CTime}
	  cd ${Tmp_dir} && mv ${Pro_name} ${Pkg_name}
	}
	
	code_tar(){
	  writelog "code_tar"
	  cd ${Tmp_dir} && tar czf ${Pkg_name}.tar.gz ${Pkg_name}
	  writelog "${Pkg_name}"
	}
	
	code_scp(){
	  writelog code_scp
	  for node in $Node_list;do
	    scp ${Tmp_dir}/${Pkg_name}.tar.gz $node:/opt/webroot/
	  done
	}
	
	code_node_remove(){
	  writelog cluster_node_remove
	}
	
	code_deploy(){
	  writelog code_deploy
	  for node in $Node_list;do
	    ssh $node "cd /opt/webroot && tar zxf ${Pkg_name}.tar.gz"
	    ssh $node "rm -f /webroot/web-demo && ln -s /opt/webroot/{Pkg_name} /webroot/web-demo"
	  done
	  scp ${Config_dir}/other/10.0.0.171.crontab.xml 10.0.0.171:/webroot/web-demo/crontab.xml
	}
	
	code_diff(){
	  echo code_diff
	  scp ${Config_dir}/other/10.0.0.171.crontab.xml 10.0.0.171:/opt/webroot/${Pkg_name}/crontab.xml
	}
	
	config_scp(){
	  echo config_scp
	}
	code_test(){
	  echo code_test
	}
	
	code_node_in(){
	  echo code_node_in
	}
	
	rollback(){
	  echo rollback
	}
	main(){
	  if [ -f ${Lock_file} ];then
	     echo "deploy is running..."
	     exit
	  fi
	  Deploy_Method=$1
	  case ${Deploy_Method} in
	    deploy)
	        shell_lock;
	        code_get;
	        code_buld;
	        code_config;
	        code_tar;
	        code_scp;
	        code_node_remove;
	        code_deploy;
	        code_diff;
	        code_test;
	        code_node_in;
	        shell_unlock;
	        ;; 
	    rollback)
	        shell_lock;
	        rollback;
	        shell_unlock;
	        ;;
	    *)
	        usage;
	  esac
	}
	main $1
	</pre>
- 关于回滚流程
	- 1. 列出回滚可用版本
	- 2. 目标移除集群
	- 3. 执行回滚
	- 4. 重启测试
	- 5. 加入集群
	>还有个紧急流程
    	>1.列出回滚版本
    	>2.执行回滚（重启）
    	>还有非常紧急情况，直接回滚上一版本
###4.
###5.