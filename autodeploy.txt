#自动化部署
- 环境的规划
	- 开发环境  
	    >开发者自己的环境，这个需要运维设置的开发环境，大家共用
	- 测试环境  
	    >功能测试环境和性能测试环境
	- 预生产环境  
		>生产环境集群中的某一个节点担任。  
		>产生的原因：数据库不一致;使用生产环境的联调接口，如：支付接口
	- 生产环境  
		>直接对用户提供服务的环境
##构建自动化部署的规划
1. 规划
2. 实现
3. 总结和扩展
###1. 规划
1. 集群有10个节点
	1. 实现一键部署10个节点
	2. 一键回滚到任意版本
	3. 一键回滚到上个版本
2. 部署
	1. git svn
	2. 代码的获取
		- svn+git直接拉取某个分支
		- svn:指定版本号
		- git:指定tag
	3. 差异解决
		1. 各个节点有差异，配置文件不一样，crontab.xml 预生产节点
		2. 代码仓库和实际的差异。配置文件是否在代码仓库中。配置文件只在部署上有，单独的项目
	4. 如何更新。Java tomcat需要更新
	5. 测试
	6. 串行和并行
		1. 分组 `salt -b`
	7. 如何执行
		1. shell ./执行
		2. web界面
###2. 流程设计
1. 获取代码（直接拉取）
2. 编译（可选）
3. 配置文件放进去
4. 打包
5. scp到目标服务器
6. 将目标服务器移除集群
7. 解压
8. 放置到webroot
9. scp差异文件
10. 重启（可选）
11. 测试
12. 加入集群
###3. 实现的shell函数
- 关于uuid
	blkid 文件
- 关于自动部署问题
	- 是否多人执行：加入锁文件
	- 记录执行日志
- 代码部分(基于shell)
	<pre># cat deploy.sh   
	#!/bin/bash
	#Node list
	Node_list="172.16.1.160 172.16.1.171"
	#Date/Time variable
	CDate=$(date "+%Y-%m-%d")
	CTime=$(date "+%H-%M-%S")
	
	Log_Date='date "+%Y-%m-%d"'
	Log_Time='date "+%H-%M-%S"'
	
	#shell env
	Shell_name="deploy.sh"
	Shell_dir="/home/www"
	Shell_log="${Shell_dir}/${Shell_name}.log"
	
	#code env
	Pro_name="web-demo"
	Code_dir="/deploy/code/web-demo"
	Config_dir="/deploy/config"
	Tmp_dir="/deploy/tmp"
	Tar_dir="/deploy/tar"
	Lock_file="/var/run/deploy.lock"
	
	usage(){
	  echo "Usage: $0 {deploy | rollback}"
	}
	
	writelog(){
	  LOGINFO=$1
	  echo "${CDate}${CTime}: ${Shell_name}: ${LOGINFO} ">>${Shell_log}
	}
	shell_lock(){
	  touch ${Lock_file}
	}
	
	shell_unlock(){
	  rm -f ${Lock_file}
	}
	code_get(){
	  writelog "code_get"
	  cd ${Code_dir} && git pull
	  cp -r ${Code_dir} ${Tmp_dir}/
	  Api_ver="123"
	}
	code_build(){
	  echo code_build
	}
	
	code_config(){
	  echo code_config
	  /bin/cp -r ${Config_dir}/* ${Tmp_dir}/${Pro_name}
	  Pkg_name=${Pro_name}_${Api_ver}_${CDate}_${CTime}
	  cd ${Tmp_dir} && mv ${Pro_name} ${Pkg_name}
	}
	
	code_tar(){
	  writelog "code_tar"
	  cd ${Tmp_dir} && tar czf ${Pkg_name}.tar.gz ${Pkg_name}
	  writelog "${Pkg_name}"
	}
	
	code_scp(){
	  writelog code_scp
	  for node in $Node_list;do
	    scp ${Tmp_dir}/${Pkg_name}.tar.gz $node:/opt/webroot/
	  done
	}
	
	code_node_remove(){
	  writelog cluster_node_remove
	}
	
	code_deploy(){
	  writelog code_deploy
	  for node in $Node_list;do
	    ssh $node "cd /opt/webroot && tar zxf ${Pkg_name}.tar.gz"
	    ssh $node "rm -f /webroot/web-demo && ln -s /opt/webroot/{Pkg_name} /webroot/web-demo"
	  done
	  scp ${Config_dir}/other/10.0.0.171.crontab.xml 10.0.0.171:/webroot/web-demo/crontab.xml
	}
	
	code_diff(){
	  echo code_diff
	  scp ${Config_dir}/other/10.0.0.171.crontab.xml 10.0.0.171:/opt/webroot/${Pkg_name}/crontab.xml
	}
	
	config_scp(){
	  echo config_scp
	}
	code_test(){
	  echo code_test
	}
	
	code_node_in(){
	  echo code_node_in
	}
	
	rollback(){
	  echo rollback
	}
	main(){
	  if [ -f ${Lock_file} ];then
	     echo "deploy is running..."
	     exit
	  fi
	  Deploy_Method=$1
	  case ${Deploy_Method} in
	    deploy)
	        shell_lock;
	        code_get;
	        code_buld;
	        code_config;
	        code_tar;
	        code_scp;
	        code_node_remove;
	        code_deploy;
	        code_diff;
	        code_test;
	        code_node_in;
	        shell_unlock;
	        ;; 
	    rollback)
	        shell_lock;
	        rollback;
	        shell_unlock;
	        ;;
	    *)
	        usage;
	  esac
	}
	main $1
	</pre>
- 关于回滚流程
	- 1. 列出回滚可用版本
	- 2. 目标移除集群
	- 3. 执行回滚
	- 4. 重启测试
	- 5. 加入集群
	>还有个紧急流程
    	>1.列出回滚版本
    	>2.执行回滚（重启）
    	>还有非常紧急情况，直接回滚上一版本
###4.更新说明
- git pull
	>频繁更新
- git tag
	>稳定更新
- 获取指定的commit id
	- master分支，可作为发布的版本
	- dev分支
###5.devops
- 什么是devops
	>- DevOps（英文Development和Operations的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。    
	>- 也是一种文化，让开发、运维、测试之间沟通的一种文化。  
	>- 目的是一样的，为了让我们的在软件构建、测试、发布更加的敏捷、频繁、可靠。
- 持续集成
	>是指在软件开发过程中，频繁地将代码集成到主干上，然后进行**自动化测试**
	>![](https://www.unixhot.com/uploads/article/20160813/95dc642c4c4230e9c1b418cb00f4e5d4.png)
- 持续交付
	>是指在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中
	>![](https://www.unixhot.com/uploads/article/20160813/95dc642c4c4230e9c1b418cb00f4e5d4.png)
- 持续部署
	> 在持续交付的基础上，把部署到生产环境的过程自动化。如果你对比上图持续部署就可以发现持续部署和持续交付的区别就是最终部署到生产环境是自动化的。
	> ![](https://www.unixhot.com/uploads/article/20160813/b15dd230dd7b351a1cce50257cb15589.png)
###6. 持续集成之Jenkins安装部署
- 安装JDK  
	`yum install -y java-1.8.0`
- 安装Jekins
	<pre>cd /etc/yum.repos.d/
	wget http://pkg.jenkins.io/redhat/jenkins.repo
	rpm --import http://pkg.jenkins.io/redhat/jenkins.io.key
	yum install -y jenkins
	systemctl start jenkins</pre>
- 访问Jenkins
	>在浏览器输入http://ip:8080来访问jenkins。解锁Jenkins，请在/var/lib/jenkins/secrets/initialAdminPassword中查看文件。
	`cat /var/lib/jenkins/secrets/initialAdminPassword` 